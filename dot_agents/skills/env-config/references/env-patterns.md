# 環境設定パターン詳細

## 目次

1. [12-Factor App の設定原則](#12-factor-app-の設定原則)
2. [環境変数バリデーションの実装パターン](#環境変数バリデーションの実装パターン)
3. [Docker/コンテナ環境での設定管理](#dockerコンテナ環境での設定管理)
4. [マルチ環境デプロイの設定戦略](#マルチ環境デプロイの設定戦略)
5. [シークレットローテーションの設計パターン](#シークレットローテーションの設計パターン)
6. [設定変更時のゼロダウンタイム戦略](#設定変更時のゼロダウンタイム戦略)
7. [設定のテスト方法](#設定のテスト方法)

---

## 12-Factor App の設定原則

12-Factor App のメソドロジーは、スケーラブルで保守性の高いアプリケーション開発のための国際的なベストプラクティスです。設定に関しては III（Config）として定義されています。

### コア原則

**原則III: 設定をコードベースから分離する**

- **定義**: 設定とコードは完全に分離すべき
- **理由**: 同じコードベースが複数の環境（dev, staging, production）にデプロイされるため、環境ごとに異なる設定が必要

### 環境変数の活用

設定の保持方法として環境変数を推奨する理由：

1. **言語・フレームワーク非依存**: すべての言語・フレームワークが環境変数にアクセス可能
2. **容易な変更**: アプリケーション再コンパイル/再起動不要（運用環境では重要）
3. **セキュリティ**: シークレット情報をコードベースに含めない
4. **デプロイメント互換性**: クラウドプラットフォーム・Kubernetes・Docker など複数のデプロイ方式に対応

### 設定の分類

設定値は以下のカテゴリに分類：

| カテゴリ | 例 | 保持方法 |
|--------|-----|--------|
| **環境固有値** | DB接続文字列、API エンドポイント | 環境変数 |
| **シークレット** | APIキー、パスワード | シークレット管理システム |
| **ビジネスロジック定数** | タイムアウト値、リトライ回数 | コード定義 or 設定ファイル |
| **デフォルト値** | ポート番号、ログレベル | コード内デフォルト |

### アンチパターン

避けるべき設定管理方法：

```
❌ config.yaml をリポジトリにコミット
❌ .env ファイルをバージョン管理に含める
❌ ハードコードされた環境固有値
❌ 環境フラグ（if ENV == "production"）に基づく動作分岐
```

---

## 環境変数バリデーションの実装パターン

環境変数の妥当性検証は、アプリケーション起動時に行うべき重要なプロセスです。

### 実装の3段階

#### 段階1: 必須変数の確認

起動時に必須な環境変数がすべて設定されているか確認：

**チェックリスト形式の実装**
```
必須変数: DATABASE_URL, API_KEY, SECRET_TOKEN
確認方法: 起動時にリスト内すべての変数が存在するか検証
失敗時動作: 詳細なエラーメッセージを出力して起動失敗
```

**エラーメッセージの設計**
```
良い例:
  必須環境変数が未設定です:
  - DATABASE_URL: 必須 (例: postgresql://user:pass@host/db)
  - API_KEY: 必須 (例: key_1234567890abcdef)

悪い例:
  Environment variable not set
```

#### 段階2: 値の形式検証

**パターンマッチング**
```
DATABASE_URL: URI形式 (scheme://user:pass@host:port/path)
PORT: 整数値（1-65535の範囲）
LOG_LEVEL: ホワイトリスト (DEBUG, INFO, WARN, ERROR)
TIMEOUT: 正の整数
BOOLEAN_FLAG: "true"/"false" (大文字小文字不問)
```

**バリデーションロジック**
```
1. 値の型チェック（文字列 → 数値変換可能か など）
2. 範囲チェック（最小値・最大値）
3. 形式チェック（正規表現マッチング）
4. 論理的整合性（複数変数間の依存関係）
```

#### 段階3: 値の論理検証

複数の設定値間の関係を確認：

```
例: リトライ設定の整合性チェック
- MAX_RETRIES = 3
- RETRY_DELAY = 1000 (ミリ秒)
- REQUEST_TIMEOUT = 500

問題: 単一リクエストが500ms以内に完了する必要があるが、
     リトライ間隔が1000msなので矛盾

チェック: REQUEST_TIMEOUT > RETRY_DELAY が成立するか確認
```

### バリデーション失敗時の対応

**原則**: Fail Fast - 起動時点で設定エラーを検出

```
起動シーケンス:
1. 環境変数読み込み
2. バリデーション実行
   ├─ 必須変数確認
   ├─ 値の形式検証
   └─ 論理検証
3. 失敗時: 詳細ログ出力 → プロセス終了コード 1
4. 成功時: アプリケーション初期化開始
```

### デフォルト値の設定戦略

**デフォルト値を設定する場合のガイドライン**

| 状況 | デフォルト値 | 理由 |
|------|-----------|------|
| 運用環境に無関係なローカル設定 | ✓ 設定OK | 例: ログレベル（DEBUG） |
| 環境固有の必須値 | ✗ 設定禁止 | 例: DB接続文字列 |
| バックオフ戦略のパラメータ | ✓ 設定OK | 例: リトライ回数（3回） |
| セキュリティ関連 | ✗ 設定禁止 | 例: APIキー |

---

## Docker/コンテナ環境での設定管理

コンテナ環境は、イメージの再利用性と設定の動的性の両立が求められます。

### 設定注入方法の比較

| 方法 | 形式 | 使用場面 | メリット | デメリット |
|------|------|--------|---------|-----------|
| **環境変数（推奨）** | `ENV_VAR=value` | すべてのシーン | 標準的、言語非依存 | 複雑な構造化データに不向き |
| **マウント済み設定ファイル** | `.env`, `config.yml` | ローカル開発 | 読みやすい | イメージに含まれる |
| **シークレットボリューム** | Docker Secrets | 本番環境 | セキュア | オーケストレーションが必要 |
| **ConfigMap/Secret** | Kubernetes | Kubernetes環境 | 動的更新可能 | K8s依存 |
| **サイドカー設定サーバー** | HTTP API | マイクロサービス | 一元管理、動的更新 | 複雑性増加 |

### Dockerfile での設定管理パターン

**パターン1: 環境変数デフォルト値の定義**
```
レイヤ: 環境変数定義
内容: ビルド時に既知のデフォルト値を設定
運用時: コンテナ起動時に上書き可能
```

**パターン2: 実行時の環境変数検証**
```
実装位置: Entrypoint スクリプト内
処理内容:
  1. 起動時に環境変数をバリデーション
  2. 不正な値の場合は起動失敗
  3. 成功時にアプリケーション起動
```

**パターン3: マルチステージビルドの活用**
```
ビルドステージ: 環境非依存の作業（コンパイル等）
ランタイムステージ: 必須環境変数のみを定義
メリット: イメージサイズ削減、設定情報の最小化
```

### docker-compose での設定管理

**方法1: .env ファイル（開発用）**
```
セキュリティレベル: 低
使用場面: ローカル開発のみ
注意: リポジトリに含めない
```

**方法2: environment セクション**
```
セキュリティレベル: 低
使用場面: 非機密設定
例: ログレベル、タイムアウト値
```

**方法3: secrets セクション**
```
セキュリティレベル: 高
使用場面: APIキー、パスワード
保存場所: ホストマシンの /run/secrets/ 内
```

### コンテナオーケストレーション（Kubernetes）での設定

**ConfigMap の使用**
```
用途: 非機密の設定データ
内容: JSON/YAML キー値ペア
参照方法: 環境変数またはボリュームマウント
更新方法: Pod の再起動が必要
```

**Secret の使用**
```
用途: 機密データ（APIキー、証明書）
暗号化: etcd で暗号化（設定による）
アクセス制御: RBAC で制限可能
更新方法: Pod の再起動が必要（通常）
```

**ダイナミック設定アプデート（Kubernetes）**
```
従来: ConfigMap 更新 → Pod 再起動
新しい方法: サイドカープロセス監視
  1. ConfigMap 変更を監視
  2. アプリケーションに通知（SIGHUP等）
  3. Pod 再起動なしで設定リロード
```

---

## マルチ環境デプロイの設定戦略

複数の環境（開発、ステージング、本番）では、同一のアプリケーションコードを異なる設定で実行します。

### 環境別の設定値管理

**推奨アーキテクチャ**

```
リポジトリ構成:
├── source code/
├── docker/
├── .github/workflows/
└── docs/

設定の保存先:
├── ローカル開発: .env (git除外)
├── ステージング: CI/CD secrets + 環境変数
├── 本番環境: シークレット管理システム + 環境変数
```

### 環境判定パターン

**方法1: 専用の環境識別変数**
```
変数: ENVIRONMENT または DEPLOYMENT_ENV
値: development, staging, production
用途: ロギングレベル、エラー通知の判定など
```

**方法2: 複合条件による環境判定**
```
条件セット:
- ENVIRONMENT == "production"
- ENABLE_METRICS == true
- LOG_LEVEL == "ERROR"

判定: すべての条件が満たされた場合のみ本番運用と判定
メリット: より厳密な環境判定
```

### 環境別設定の差分管理

**パターン1: 基本テンプレート + 上書き**
```
基本設定ファイル: config.default.yml
環境別上書き: config.production.yml, config.staging.yml

マージ順序:
1. デフォルト値をロード
2. 環境別ファイルで上書き
3. 環境変数で最終上書き

優先度: 環境変数 > 環境別ファイル > デフォルト > コード内
```

**パターン2: 環境変数プリフィックス**
```
例:
PROD_DATABASE_URL (本番用)
STG_DATABASE_URL (ステージング用)
DEV_DATABASE_URL (開発用)

実装: ENVIRONMENT の値に応じて該当プリフィックスの値を読み込む
メリット: 複数環境の設定を同時に保持可能
```

### 環境昇格フロー

```
ローカル開発
    ↓ (コード検証・テスト実施)
ステージング環境
    ↓ (統合テスト・性能テスト)
本番環境
```

**各ステップでの設定検証**

| ステップ | 検証項目 | 失敗時対応 |
|---------|--------|----------|
| ローカル開発 | 設定の形式、 型チェック | ログ出力 → 起動失敗 |
| ステージング | 本番同等の設定で動作確認 | デプロイ停止 |
| 本番環境 | 最終的な接続性テスト | 自動ロールバック |

---

## シークレットローテーションの設計パターン

セキュリティ要件として、定期的にシークレット（APIキー、パスワード、証明書）を更新する必要があります。

### ローテーション戦略

**戦略1: 可用性優先（ブルーグリーンローテーション）**

```
フェーズ1: 古い秘密鍵（Blue）と新しい秘密鍵（Green）の両方を有効化
フェーズ2: クライアント側が新しい秘密鍵に切り替わるまで待機
フェーズ3: 古い秘密鍵の無効化

特徴: ダウンタイム なし、クライアント対応時間が必要
適用場面: 外部クライアント向けのAPIキー
```

**戦略2: 計画的ローテーション（計画済みメンテナンス）**

```
フェーズ1: ローテーション予定を事前通知（1-2週間前）
フェーズ2: メンテナンスウィンドウ中に古い秘密鍵を無効化
フェーズ3: 新しい秘密鍵のみを使用

特徴: シンプル、計画済みのため準備可能
適用場面: 社内統制下のサービス
```

**戦略3: 自動ローテーション（ゼロトラスト）**

```
仕組み:
1. 秘密鍵自動生成スケジューラ（例：月1回）
2. 古い鍵を無効化する前に新しい鍵を配布
3. アプリケーション側で複数鍵の同時検証対応
4. 一定期間後に古い鍵を完全削除

利点: 手動作業なし、侵害時の影響最小化
課題: 実装複雑度高、複数秘密鍵の管理が必要
```

### ローテーション実装時の考慮事項

**シークレット配布の方式**

| 方式 | 特徴 | 用途 |
|------|------|------|
| **環境変数上書き** | Pod/プロセス再起動が必要 | 計画的メンテナンス |
| **ボリュームマウント更新** | ファイル自動リロード対応 | 頻繁なローテーション |
| **API側の対応** | 複数秘密鍵の並行検証 | 外部向けAPI |
| **ハードコード更新** | ビルドし直し必要 | 非推奨 |

**ローテーション中の監視**

```
監視項目:
1. 認証失敗率の急激な上昇
2. ログ出力の異常
3. 旧秘密鍵での接続試行
4. 新秘密鍵への切り替え状況

対応フロー:
異常検知 → アラート → 手動対応 または 自動ロールバック
```

### 秘密鍵管理システムとの連携

**集中管理システムの利用**

```
役割: HashiCorp Vault、AWS Secrets Manager、Azure Key Vault など
機能:
  - 秘密鍵の一元保管
  - 自動ローテーション機能
  - アクセス監査ログ
  - TTL設定（有効期限管理）

連携方法:
  1. アプリケーション起動時に秘密鍵を取得
  2. 定期的に秘密鍵を再取得（キャッシュ更新）
  3. 秘密鍵更新通知の処理
```

---

## 設定変更時のゼロダウンタイム戦略

本番環境では、設定変更に伴うサービス停止を回避することが重要です。

### ゼロダウンタイムの実現パターン

**パターン1: ホットリロード**

```
仕組み:
1. アプリケーションが設定ファイルの変更を監視
2. 変更検知時にシグナル（SIGHUP など）受信
3. 新しい設定を読み込み、既存接続は継続
4. 新しい接続には新しい設定を適用

実装点:
- ファイルシステム監視（inotify など）
- シグナルハンドラ実装
- 設定の不変性（変更中もアプリ動作に影響なし）

対応言語: すべてのプログラミング言語で実装可能
```

**パターン2: 複数プロセスの段階的置き換え**

```
シナリオ: 複数ワーカープロセスが起動している場合

フロー:
1. 新しい設定でワーカープロセスを起動（新プロセス）
2. ロードバランサから旧プロセスへのトラフィック停止
3. 旧プロセスの既存接続が完了するまで待機
4. 旧プロセスを停止

特徴: 段階的置き換え、ダウンタイムなし
対応: Kubernetes、Docker Swarm など
```

**パターン3: ブルーグリーンデプロイメント**

```
概要: 2つの同一環境を用意、切り替え時にルーティング変更

Blue 環境（旧設定）
    ↓ (新設定でデプロイ)
Green 環境（新設定）
    ↓ (ヘルスチェック実施)
接続成功 → トラフィック切り替え
失敗 → ロールバック

利点: 即座のロールバック可能、リスク最小
コスト: インフラ倍必要
```

**パターン4: 設定バージョニング**

```
概念:
- 設定ファイルにバージョン番号を付与
- 複数バージョン同時保持
- 実行時にバージョン指定

実装:
CONFIG_VERSION=2.1.0 環境変数で指定
リポジトリ: config/v2.1.0/app.yml

メリット: ロールバック容易、複数バージョン検証可
```

### 設定変更の安全性を保証するチェックリスト

```
変更前:
☐ 新設定の妥当性テスト実施
☐ ステージング環境での動作確認
☐ ロールバック計画の立案
☐ 監視・アラート設定の確認

変更実施中:
☐ リアルタイム監視の開始
☐ エラーログ・メトリクスの確認
☐ ユーザー影響の把握

変更後:
☐ サービス正常性の最終確認
☐ パフォーマンスメトリクスの検証
☐ 変更ログへの記録
```

### トランザクション的な設定変更

複雑な変更の場合、複数の設定項目を原子的に変更する必要があります：

```
原子性の実装:
1. 新しい設定セットをまず作成・検証
2. コミットフェーズで一括適用
3. どちらかが失敗した場合は全体ロールバック

ファイルシステムの例:
  config.current.yml（実行中の設定）
  config.new.yml（新しい設定）
  
  検証成功 → config.current = config.new
  検証失敗 → config.new削除、config.current 維持
```

---

## 設定のテスト方法

設定の妥当性を確保するため、複数レベルのテストが必要です。

### テストレベルと実装方法

#### レベル1: 静的チェック（起動前）

**単体テスト形式**

```
テスト内容: 環境変数の形式検証
例:
  - ポート番号が整数か
  - DB接続文字列が妥当な形式か
  - ホスト名が解決可能か（DNS check）
  - 必須変数がすべて存在するか

実装: Validation Framework を用いたスキーマチェック
```

**チェックリスト例**

```
変数: DATABASE_URL
形式チェック: URI形式（scheme://host:port/path）
型チェック: 文字列型
範囲チェック: 接続タイムアウト値が妥当か
論理検証: ユーザー名とパスワードが指定されているか
```

#### レベル2: 統合テスト（起動時）

**実環境シミュレーション**

```
テスト環境: Docker コンテナ、Kubernetes ポッド
実施項目:
  1. 環境変数を指定してコンテナ起動
  2. アプリケーション初期化成功確認
  3. 外部リソースへの接続確認
     - データベース接続
     - 外部 API への疎通確認
     - ファイルシステムアクセス

検証方法: ヘルスチェックエンドポイント、ログ出力確認
```

#### レベル3: 機能テスト（実行時）

**エンドツーエンドテスト**

```
テスト対象: 設定値がアプリケーション動作に正しく反映されるか

例:
- LOG_LEVEL=DEBUG で詳細ログが出力されるか
- REQUEST_TIMEOUT=5000 でタイムアウトが5秒で発生するか
- MAX_RETRY=3 で3回まで再試行されるか

実装: シナリオベースのテストスイート
```

#### レベル4: パフォーマンステスト

**環境ごとの動作確認**

```
測定項目:
  - 設定読み込みのオーバーヘッド
  - メモリ使用量
  - 起動時間

基準値設定と比較:
  - ステージング環境と本番環境の性能差を確認
  - 予期しない遅延がないか検証
```

### テスト実装パターン

**パターン1: 環境変数のパラメータ化テスト**

```
フレームワーク: pytest（Python）、JUnit（Java）など

実装:
test_config_with_valid_database_url()
test_config_with_invalid_database_url()
test_config_with_missing_required_variable()
test_config_with_out_of_range_port_number()

実施: 複数の環境変数セットでテストを反復実行
```

**パターン2: テストコンテナの使用**

```
ツール: Testcontainers（複数言語対応）

利点:
  - 実際のサービス（DB, Redis など）をコンテナで実行
  - テスト間での依存性排除
  - CI/CD パイプラインでの再現可能性

例:
  1. テスト開始時にPostgreSQL コンテナ起動
  2. DATABASE_URL を動的に設定
  3. アプリケーション起動・機能テスト実施
  4. テスト終了時にコンテナ削除
```

**パターン3: フィクスチャ（テストデータ）の管理**

```
構成:
.test/
├── fixtures/
│   ├── config.valid.env
│   ├── config.staging.env
│   ├── config.production.env
│   └── config.invalid.env
└── test_config.py

使用方法:
テスト内で指定したフィクスチャファイルを読み込み
期待される動作を検証
```

### CI/CD パイプラインでの設定テスト

**パイプラインステップ**

```
1. Lint ステップ
   - 環境変数定義ファイルの形式チェック
   - ツール: shellcheck, yamllint など

2. Validation ステップ
   - 必須変数の確認
   - 形式チェック実行
   
3. Build ステップ
   - Docker イメージビルド時に設定検証
   
4. Test ステップ
   - ユニットテスト実行
   - 統合テスト実行（テスト環境設定で）
   
5. Deploy ステップ
   - ステージング環境で最終検証
   - 本番環境への反映
```

**通知と可視化**

```
テスト結果:
- 失敗時: 詳細なエラーメッセージ表示
  例: "DATABASE_URL が無効な形式です。期待値: postgresql://..."
  
- ログアーティファクト保存
  - ステップごとのログ保存
  - 失敗時の完全スタックトレース記録

可視化:
- ダッシュボード表示
- テストカバレッジレポート
- トレンド分析（設定変更後の安定性）
```

### 設定テストの課題と対策

| 課題 | 対策 |
|------|------|
| シークレット情報のテスト漏洩 | テスト用ダミー値を使用、本物のシークレット参照禁止 |
| 環境依存テストの不安定性 | テストコンテナで独立した環境を用意 |
| 設定変更テストの手間 | パラメータ化テスト導入で自動化 |
| 本番同等環境の構築困難 | Infrastructure as Code で再現可能性確保 |

---

## まとめ

環境設定は、アプリケーションの可用性・セキュリティ・保守性に直結する重要な要素です。

### 推奨される統合的アプローチ

```
1. 原則: 12-Factor App ガイドラインに従う
2. 実装: 環境変数を中心とした設定管理
3. 検証: Fail Fast による早期エラー検知
4. 展開: マルチ環境で段階的な検証
5. 運用: ゼロダウンタイムを目指した設定変更
6. テスト: 複数レベルでの体系的なテスト
```

### チェックリスト（導入時の確認）

- [ ] 設定とコードが完全に分離されているか
- [ ] すべての環境変数にバリデーションが実装されているか
- [ ] シークレット情報が適切に保護されているか
- [ ] マルチ環境対応が設計・実装されているか
- [ ] ローテーション・更新時のゼロダウンタイム対応ができているか
- [ ] テストが包括的かつ自動化されているか
