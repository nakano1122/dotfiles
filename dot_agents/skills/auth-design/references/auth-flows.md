# 認証フロー詳細と実装パターン

## 目次

1. [ログインフロー](#ログインフロー)
   - [基本的なパスワード認証](#基本的なパスワード認証)
   - [シーケンス図](#ログインのシーケンス図)
   - [実装パターン](#ログインの実装パターン)
2. [ユーザー登録フロー](#ユーザー登録フロー)
   - [メール認証を含む登録](#メール認証を含む登録)
   - [シーケンス図](#登録のシーケンス図)
   - [実装パターン](#登録の実装パターン)
3. [パスワードリセットフロー](#パスワードリセットフロー)
   - [トークンベースのリセット](#トークンベースのリセット)
   - [シーケンス図](#パスワードリセットのシーケンス図)
   - [実装パターン](#パスワードリセットの実装パターン)
4. [多要素認証(MFA)フロー](#多要素認証mfaフロー)
   - [TOTP方式](#totp方式)
   - [SMS方式](#sms方式)
   - [シーケンス図](#mfaのシーケンス図)
   - [実装パターン](#mfaの実装パターン)
5. [トークンライフサイクル管理](#トークンライフサイクル管理)
   - [アクセストークンとリフレッシュトークン](#アクセストークンとリフレッシュトークン)
   - [トークンの無効化と失効](#トークンの無効化と失効)
   - [実装パターン](#トークンの実装パターン)
6. [セッション管理パターン](#セッション管理パターン)
   - [ステートレスセッション](#ステートレスセッション)
   - [ステートフルセッション](#ステートフルセッション)
   - [ハイブリッドアプローチ](#ハイブリッドアプローチ)
7. [ソーシャルログイン(OAuth)統合](#ソーシャルログインoauth統合)
   - [OAuth 2.0フロー](#oauth-20フロー)
   - [シーケンス図](#oauthのシーケンス図)
   - [アカウント連携パターン](#アカウント連携パターン)
8. [Remember Me実装](#remember-me実装)
   - [永続的トークン方式](#永続的トークン方式)
   - [セキュリティ考慮事項](#remember-meのセキュリティ)
9. [アカウントロックアウト戦略](#アカウントロックアウト戦略)
   - [失敗回数ベースのロック](#失敗回数ベースのロック)
   - [時間ベースのロック](#時間ベースのロック)
   - [段階的な制限](#段階的な制限)

---

## ログインフロー

### 基本的なパスワード認証

ユーザー名(またはメールアドレス)とパスワードを用いた最も基本的な認証フロー。

**主要なステップ:**

1. ユーザーが認証情報を入力
2. サーバーが認証情報を検証
3. パスワードハッシュの比較
4. セッション/トークンの発行
5. クライアントへの応答

### ログインのシーケンス図

```
ユーザー              クライアント           サーバー            データベース
  |                      |                    |                    |
  |--入力: ID/PW-------->|                    |                    |
  |                      |                    |                    |
  |                      |--POST /login------>|                    |
  |                      |  {username, pw}    |                    |
  |                      |                    |                    |
  |                      |                    |--ユーザー取得----->|
  |                      |                    |<--ユーザーデータ---|
  |                      |                    |                    |
  |                      |                    |--パスワード検証--->|
  |                      |                    |  (ハッシュ比較)    |
  |                      |                    |                    |
  |                      |                    |--失敗回数チェック->|
  |                      |                    |<--ロック状態-------|
  |                      |                    |                    |
  |                      |                    |--トークン生成----->|
  |                      |                    |--セッション保存--->|
  |                      |                    |                    |
  |                      |<--200 OK-----------|                    |
  |                      |  {token, user}     |                    |
  |                      |                    |                    |
  |<--ログイン成功-------|                    |                    |
  |   トークン保存       |                    |                    |
```

### ログインの実装パターン

#### パターン1: ベーシック認証

```
フロー:
1. ユーザー識別子でユーザーを検索
2. ユーザーの存在チェック
3. アカウントのアクティブ状態確認
4. パスワードハッシュの検証
5. ログイン成功時の処理
   - セッション/トークン生成
   - 最終ログイン時刻の更新
   - 失敗カウンターのリセット
6. ログイン失敗時の処理
   - 失敗カウンターの増加
   - ロックアウトチェック
   - 遅延応答(タイミング攻撃対策)
```

**セキュリティ考慮事項:**

- パスワードは必ずハッシュ化して保存(bcrypt, argon2等)
- タイミング攻撃対策として固定時間の応答
- ユーザー存在の有無を推測できないエラーメッセージ
- レート制限の実装(IPアドレス、ユーザー単位)
- ログイン試行のログ記録

#### パターン2: 多段階認証付きログイン

```
フロー:
1. 第一段階: ID/パスワード検証
2. 第二段階: MFA検証
   - TOTPコード
   - SMSコード
   - メール認証
   - バイオメトリクス
3. 全段階成功後にトークン発行
```

---

## ユーザー登録フロー

### メール認証を含む登録

新規ユーザーがアカウントを作成し、メールアドレスを確認するフロー。

### 登録のシーケンス図

```
ユーザー              クライアント           サーバー            データベース        メールサービス
  |                      |                    |                    |                    |
  |--登録情報入力------->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--POST /register--->|                    |                    |
  |                      |  {email, pw, ...}  |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--重複チェック----->|                    |
  |                      |                    |<--チェック結果-----|                    |
  |                      |                    |                    |                    |
  |                      |                    |--バリデーション--->|                    |
  |                      |                    |                    |                    |
  |                      |                    |--ユーザー作成----->|                    |
  |                      |                    |  (status: pending) |                    |
  |                      |                    |                    |                    |
  |                      |                    |--確認トークン生成->|                    |
  |                      |                    |<--トークン保存-----|                    |
  |                      |                    |                    |                    |
  |                      |                    |--確認メール送信---------------->|
  |                      |                    |  (トークン含むURL)             |
  |                      |                    |                    |                    |
  |                      |<--201 Created------|                    |                    |
  |                      |  {message}         |                    |                    |
  |                      |                    |                    |                    |
  |<--確認メール送信-----|                    |                    |                    |
  |                      |                    |                    |                    |
  |--メール受信----------|                    |                    |                    |
  |--リンククリック----->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--GET /verify------>|                    |                    |
  |                      |  ?token=xxx        |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--トークン検証----->|                    |
  |                      |                    |--有効期限チェック->|                    |
  |                      |                    |                    |                    |
  |                      |                    |--アカウント有効化->|                    |
  |                      |                    |  (status: active)  |                    |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |<--登録完了-----------|                    |                    |                    |
```

### 登録の実装パターン

#### パターン1: 即時登録(メール確認なし)

```
フロー:
1. 入力データのバリデーション
   - 必須項目チェック
   - 形式チェック(メール、パスワード強度等)
2. 重複チェック
   - メールアドレス
   - ユーザー名
3. パスワードのハッシュ化
4. ユーザーレコード作成
5. 自動ログイン(オプション)
6. ウェルカムメール送信
```

#### パターン2: メール確認必須登録

```
フロー:
1. 仮登録
   - ユーザーレコード作成(status: pending)
   - 確認トークン生成(ランダム文字列、UUID等)
   - トークンの保存(有効期限付き)
2. 確認メール送信
   - トークンを含むURLを生成
   - メール送信キューに追加
3. メール確認処理
   - トークン検証
   - 有効期限チェック
   - アカウント有効化(status: active)
   - トークン無効化
4. 確認後の処理
   - 自動ログイン or ログインページへ誘導
```

**セキュリティ考慮事項:**

- メールアドレスの正規化(小文字変換、空白除去)
- パスワード強度チェック(最小文字数、複雑性)
- CAPTCHA/reCAPTCHA実装(ボット対策)
- レート制限(同一IPからの大量登録防止)
- 確認トークンの有効期限(24時間等)
- 使用済みトークンの再利用防止

#### パターン3: 二段階登録(個人情報分離)

```
フロー:
1. 第一段階: 基本情報登録
   - メールアドレス、パスワード
   - メール確認
2. 第二段階: 詳細情報登録
   - プロフィール情報
   - 設定情報
```

---

## パスワードリセットフロー

### トークンベースのリセット

ユーザーがパスワードを忘れた場合の安全なリセットフロー。

### パスワードリセットのシーケンス図

```
ユーザー              クライアント           サーバー            データベース        メールサービス
  |                      |                    |                    |                    |
  |--リセット要求------->|                    |                    |                    |
  |  (メール入力)        |                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--POST /reset------>|                    |                    |
  |                      |  {email}           |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--ユーザー検索----->|                    |
  |                      |                    |<--ユーザー情報-----|                    |
  |                      |                    |                    |                    |
  |                      |                    |--リセットトークン->|                    |
  |                      |                    |  生成・保存        |                    |
  |                      |                    |                    |                    |
  |                      |                    |--リセットメール送信------------>|
  |                      |                    |  (トークン含むURL)             |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |                      |  {message}         |                    |                    |
  |                      |                    |                    |                    |
  |<--確認メッセージ-----|                    |                    |                    |
  |                      |                    |                    |                    |
  |--メール受信----------|                    |                    |                    |
  |--リンククリック----->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--GET /reset/verify>|                    |                    |
  |                      |  ?token=xxx        |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--トークン検証----->|                    |
  |                      |                    |<--検証結果---------|                    |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |                      |  リセットフォーム  |                    |                    |
  |                      |                    |                    |                    |
  |--新PW入力----------->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--POST /reset/confirm|                   |                    |
  |                      |  {token, new_pw}   |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--トークン再検証--->|                    |
  |                      |                    |--PWハッシュ化----->|                    |
  |                      |                    |--PW更新----------->|                    |
  |                      |                    |--トークン無効化--->|                    |
  |                      |                    |--全セッション無効化>|                    |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |<--完了通知-----------|                    |                    |                    |
```

### パスワードリセットの実装パターン

#### パターン1: 標準的なトークンベースリセット

```
リセット要求フロー:
1. メールアドレスの受付
2. ユーザー検索
   - ユーザーが存在しない場合も成功レスポンス(情報漏洩防止)
3. リセットトークン生成
   - ランダム文字列(256bit以上)
   - 有効期限設定(1時間推奨)
   - トークンのハッシュ化保存
4. リセットURL生成
5. メール送信
6. 前回のリセットトークン無効化

リセット実行フロー:
1. トークン検証
   - 存在チェック
   - 有効期限チェック
   - 使用済みフラグチェック
2. 新パスワードのバリデーション
3. パスワード更新
4. トークン無効化
5. 全セッション・トークンの無効化
6. パスワード変更完了メール送信
```

**セキュリティ考慮事項:**

- トークンは十分に長く、推測不可能にする
- トークンの有効期限を短く設定(1-2時間)
- トークンは一度のみ使用可能
- リセット後は全セッションを無効化
- パスワード変更の通知メール送信
- レート制限(同一メールへの連続要求)
- タイミング攻撃対策(存在しないユーザーでも同じ処理時間)

#### パターン2: セキュリティ質問併用

```
フロー:
1. メールアドレス入力
2. セキュリティ質問表示
3. 回答検証
4. トークンベースのリセット処理
```

#### パターン3: SMS確認併用

```
フロー:
1. メールアドレス入力
2. 登録済み電話番号へSMS送信
3. SMS確認コード検証
4. パスワードリセット実行
```

---

## 多要素認証(MFA)フロー

### TOTP方式

時刻ベースのワンタイムパスワード認証。

**特徴:**
- オフラインで動作可能
- 認証アプリ使用(Google Authenticator等)
- 30秒ごとにコード生成

### SMS方式

電話番号へのコード送信による認証。

**特徴:**
- デバイス不要(携帯電話のみ)
- コスト発生(SMS送信料)
- セキュリティは比較的低い

### MFAのシーケンス図

```
ユーザー              クライアント           サーバー            データベース        SMSサービス
  |                      |                    |                    |                    |
  |==第一認証: パスワード==================================|                    |
  |                      |                    |                    |                    |
  |--ID/PW入力---------->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--POST /login------>|                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--認証処理--------->|                    |
  |                      |                    |<--MFA有効フラグ----|                    |
  |                      |                    |                    |                    |
  |                      |                    |--一時トークン生成->|                    |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |                      |  {requires_mfa: true, temp_token}       |                    |
  |                      |                    |                    |                    |
  |==第二認証: MFA==========================================|                    |
  |                      |                    |                    |                    |
  |                      |--POST /mfa/send--->|                    |                    |
  |                      |  {temp_token}      |                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--MFA方式確認------>|                    |
  |                      |                    |                    |                    |
  |                      |                    |--コード生成・保存->|                    |
  |                      |                    |                    |                    |
  |                      |                    |--SMS送信(SMS方式の場合)-------->|
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |                      |                    |                    |                    |
  |<--コード入力画面-----|                    |                    |                    |
  |                      |                    |                    |                    |
  |--コード入力--------->|                    |                    |                    |
  |                      |                    |                    |                    |
  |                      |--POST /mfa/verify->|                    |                    |
  |                      |  {temp_token, code}|                    |                    |
  |                      |                    |                    |                    |
  |                      |                    |--コード検証------->|                    |
  |                      |                    |<--検証結果---------|                    |
  |                      |                    |                    |                    |
  |                      |                    |--本トークン発行--->|                    |
  |                      |                    |--セッション作成--->|                    |
  |                      |                    |                    |                    |
  |                      |<--200 OK-----------|                    |                    |
  |                      |  {token, user}     |                    |                    |
  |                      |                    |                    |                    |
  |<--ログイン完了-------|                    |                    |                    |
```

### MFAの実装パターン

#### パターン1: TOTP実装

```
セットアップフロー:
1. ユーザーがMFA有効化を選択
2. サーバーでシークレット生成
3. QRコード生成(シークレット含む)
4. ユーザーが認証アプリでスキャン
5. 確認コード入力で検証
6. シークレットを暗号化して保存
7. リカバリーコード生成(10個程度)

ログイン時検証フロー:
1. 第一認証(パスワード)成功
2. MFA有効フラグチェック
3. 一時トークン発行
4. TOTPコード要求
5. コード検証
   - 時刻同期許容(±1期間)
   - リプレイ攻撃防止(使用済みコード記録)
6. 検証成功で本セッション発行
```

**TOTP検証ロジック:**
```
検証対象期間:
- 現在の時刻
- 1期間前(30秒前)
- 1期間後(30秒後)

検証手順:
1. 各期間でコード生成
2. 入力コードと比較
3. 一致すれば成功
4. 同じコードの再利用防止
```

#### パターン2: SMS実装

```
セットアップフロー:
1. ユーザーが電話番号登録
2. 確認コード送信
3. コード検証
4. 電話番号保存

ログイン時検証フロー:
1. 第一認証成功
2. ランダムコード生成(6桁数字)
3. コードを一時保存(有効期限5分)
4. SMS送信
5. ユーザーコード入力
6. コード検証
7. 検証成功で本セッション発行
```

**セキュリティ考慮事項:**

- SMS送信回数制限(レート制限)
- コードの有効期限(5分推奨)
- コードの複雑性(最低6桁)
- 同じコードの再送防止
- 送信失敗時のリトライ制御

#### パターン3: バックアップコード

```
実装:
1. ランダムな8-10桁コード10個生成
2. ハッシュ化して保存
3. ユーザーに一度だけ表示
4. 各コードは1回のみ使用可能
5. 使用済みフラグ管理
6. 残数が少なくなったら警告
```

#### MFA信頼デバイス機能

```
フロー:
1. MFA検証成功時に「このデバイスを信頼」オプション
2. デバイス識別子生成(ランダムトークン)
3. デバイス情報保存
   - デバイスID
   - ユーザーID
   - 作成日時
   - 最終使用日時
   - User-Agent
   - IPアドレス(参考)
4. 次回ログイン時
   - デバイスIDチェック
   - 信頼デバイスならMFAスキップ
5. 信頼デバイス管理
   - 有効期限(30日等)
   - ユーザーによる無効化機能
   - 最大登録数制限
```

---

## トークンライフサイクル管理

### アクセストークンとリフレッシュトークン

**アクセストークン:**
- 短命(15分-1時間)
- APIリクエストに使用
- ペイロードに最小限の情報

**リフレッシュトークン:**
- 長命(日-週-月)
- アクセストークン更新専用
- より厳格な保存・検証

### 二重トークン方式のフロー

```
初回ログイン:
1. 認証成功
2. アクセストークン生成(有効期限: 15分)
3. リフレッシュトークン生成(有効期限: 7日)
4. 両方返却

API呼び出し:
1. アクセストークンをヘッダーに含める
2. サーバーで検証
3. 有効なら処理実行
4. 無効/期限切れならエラー(401)

トークンリフレッシュ:
1. アクセストークン期限切れ
2. リフレッシュトークンで更新要求
3. リフレッシュトークン検証
4. 新しいアクセストークン発行
5. (オプション)新しいリフレッシュトークン発行(ローテーション)
6. 古いリフレッシュトークン無効化
```

### トークンリフレッシュのシーケンス図

```
クライアント           サーバー            データベース
  |                      |                    |
  |--API呼び出し-------->|                    |
  | (アクセストークン)   |                    |
  |                      |                    |
  |                      |--トークン検証----->|
  |                      |<--期限切れ---------|
  |                      |                    |
  |<--401 Unauthorized---|                    |
  |                      |                    |
  |--POST /refresh------>|                    |
  | (リフレッシュトークン)|                   |
  |                      |                    |
  |                      |--トークン検証----->|
  |                      |<--有効-------------|
  |                      |                    |
  |                      |--新トークン生成--->|
  |                      |--保存------------->|
  |                      |--旧トークン無効化->|
  |                      |                    |
  |<--200 OK-------------|                    |
  | {new_access_token,   |                    |
  |  new_refresh_token}  |                    |
  |                      |                    |
  |--API再試行---------->|                    |
  | (新アクセストークン) |                    |
  |                      |                    |
  |<--200 OK-------------|                    |
```

### トークンの無効化と失効

**手動無効化:**
```
シナリオ:
- ユーザーログアウト
- パスワード変更
- アカウント削除
- セキュリティ違反検出

実装:
1. ブラックリスト方式
   - 無効化したトークンをDBに保存
   - 検証時にブラックリストチェック
   - 期限切れトークンは自動削除

2. トークンバージョン方式
   - ユーザーにトークンバージョン番号付与
   - トークンにバージョン埋め込み
   - 無効化時はバージョンインクリメント
   - 古いバージョンのトークンは無効

3. 全トークン無効化
   - ユーザーの全セッション・トークン削除
   - トークンバージョンリセット
```

### トークンの実装パターン

#### パターン1: JWT(JSON Web Token)

```
構造:
Header.Payload.Signature

ペイロード例:
{
  "sub": "user_id_123",
  "iat": 1707724800,
  "exp": 1707725700,
  "type": "access",
  "version": 1
}

利点:
- ステートレス(サーバー側保存不要)
- 自己完結型
- 広くサポートされている

欠点:
- 即座の無効化が困難
- トークンサイズが大きい
- ペイロード情報が見える(暗号化なし)
```

#### パターン2: オペークトークン

```
構造:
ランダム文字列(例: "a8f5f167f44f4964e6c998dee827110c")

特徴:
- サーバー側でマッピング管理
- 即座の無効化が容易
- トークンサイズが小さい
- ペイロード情報が外部から見えない

実装:
1. トークン生成
   - 暗号学的に安全な乱数生成
   - 128bit以上推奨
2. データベースに保存
   - token_id (主キー)
   - user_id
   - token_type (access/refresh)
   - expires_at
   - created_at
   - last_used_at
   - device_info
3. 検証時はDB lookup
```

#### パターン3: ハイブリッド方式

```
アクセストークン: JWT(短命、ステートレス)
リフレッシュトークン: オペークトークン(長命、DB管理)

利点:
- アクセストークンの検証が高速
- リフレッシュトークンは厳格に管理
- バランスの取れたセキュリティ
```

---

## セッション管理パターン

### ステートレスセッション

サーバー側で状態を保持しない方式。

**実装:**
```
方式: JWT等の自己完結型トークン

メリット:
- サーバーの水平スケーリングが容易
- DB負荷が低い
- CDN/キャッシュと相性が良い

デメリット:
- 即座のセッション無効化が困難
- トークンサイズが大きい
- リフレッシュまでは情報更新不可

適用場面:
- マイクロサービス
- 高負荷API
- 公開API
```

### ステートフルセッション

サーバー側でセッション情報を管理する方式。

**実装:**
```
方式: セッションIDとサーバー側ストレージ

セッションストレージ選択肢:
1. インメモリ(開発環境のみ)
2. データベース
3. Redis/Memcached等のキャッシュ

メリット:
- 即座のセッション無効化が可能
- セッション情報の更新が容易
- トークンサイズが小さい

デメリット:
- サーバー負荷が高い
- スケーリングが複雑
- ストレージ依存

適用場面:
- 管理画面
- セキュリティ重視アプリ
- セッション情報が多い場合
```

### ハイブリッドアプローチ

```
実装例:
1. セッションIDはステートレス(JWT)
2. 重要な変更時のみサーバー側チェック
3. トークンバージョニング

フロー:
1. JWTにバージョン番号埋め込み
2. 通常はJWT検証のみ
3. 重要な操作時はDBでバージョンチェック
4. パスワード変更等でバージョンインクリメント

メリット:
- 通常時は高速
- セキュリティイベント時は厳格
- バランスの良いパフォーマンス
```

### セッション実装の詳細

#### セッションストレージスキーマ

```
テーブル: sessions
- session_id (主キー, ランダム文字列)
- user_id (外部キー)
- created_at (作成日時)
- expires_at (有効期限)
- last_activity_at (最終アクティビティ)
- ip_address (IPアドレス)
- user_agent (ブラウザ情報)
- device_type (デバイス種別)
- is_active (アクティブフラグ)
- session_data (JSON, セッション固有データ)

インデックス:
- user_id (複数セッション検索用)
- expires_at (期限切れセッション削除用)
```

#### セッションセキュリティ機能

```
1. セッション固定攻撃対策
   - ログイン成功時にセッションID再生成
   - 権限変更時にセッションID再生成

2. セッションハイジャック対策
   - IPアドレスチェック(緩やか)
   - User-Agentチェック
   - 異常なアクティビティ検出

3. アイドルタイムアウト
   - 最終アクティビティから一定時間でタイムアウト
   - 絶対タイムアウト(最大セッション時間)

4. 同時セッション制限
   - ユーザーあたりの最大セッション数
   - 新規ログイン時の古いセッション削除オプション
```

---

## ソーシャルログイン(OAuth)統合

### OAuth 2.0フロー

代表的なフローは「Authorization Code Flow」。

### OAuthのシーケンス図

```
ユーザー      クライアント     自システムサーバー   OAuthプロバイダ    データベース
  |              |                  |                  |                  |
  |--ソーシャルログインボタンクリック>|                  |                  |
  |              |                  |                  |                  |
  |              |--認可URL生成要求->|                  |                  |
  |              |                  |                  |                  |
  |              |<--認可URL---------|                  |                  |
  |              |                  |                  |                  |
  |--リダイレクト----------------->OAuthプロバイダ      |                  |
  |              |                  |                  |                  |
  |<--ログイン画面------------------|OAuthプロバイダ    |                  |
  |              |                  |                  |                  |
  |--認証情報入力----------------->OAuthプロバイダ      |                  |
  |              |                  |                  |                  |
  |<--権限確認画面-----------------|OAuthプロバイダ     |                  |
  |              |                  |                  |                  |
  |--権限許可---------------------->OAuthプロバイダ     |                  |
  |              |                  |                  |                  |
  |--コールバックURL-------------->|                  |                  |
  |  ?code=xxx&state=yyy           |                  |                  |
  |              |                  |                  |                  |
  |              |                  |--トークン交換要求---------------->|
  |              |                  |  (code, client_secret)            |
  |              |                  |                  |                  |
  |              |                  |<--アクセストークン----------------|
  |              |                  |                  |                  |
  |              |                  |--ユーザー情報取得--------------->|
  |              |                  |  (access_token)  |                  |
  |              |                  |                  |                  |
  |              |                  |<--ユーザープロフィール-----------|
  |              |                  |                  |                  |
  |              |                  |--ユーザー検索/作成-------------->|
  |              |                  |  (OAuth ID)      |                  |
  |              |                  |<--ユーザー情報-------------------|
  |              |                  |                  |                  |
  |              |                  |--セッション作成----------------->|
  |              |                  |                  |                  |
  |              |<--リダイレクト---|                  |                  |
  |              |  (自システムトークン)|               |                  |
  |              |                  |                  |                  |
  |<--ログイン完了|                  |                  |                  |
```

### アカウント連携パターン

#### パターン1: 新規登録のみ

```
フロー:
1. OAuth認証成功
2. プロバイダIDで既存ユーザー検索
3. 存在しなければ新規作成
4. 存在すればエラー(別のログイン方法を促す)

データ構造:
users テーブル:
- user_id
- email
- created_at

oauth_accounts テーブル:
- oauth_account_id
- user_id (外部キー)
- provider (google, github, facebook等)
- provider_user_id
- access_token (暗号化)
- refresh_token (暗号化)
- token_expires_at
- created_at
- updated_at
```

#### パターン2: 既存アカウント連携

```
フロー:
1. OAuth認証成功
2. プロバイダIDで検索
3. 既存連携があればログイン
4. なければメールアドレスで既存ユーザー検索
   a. 既存ユーザーあり
      - 確認画面表示
      - ユーザー同意でアカウント連携
   b. 既存ユーザーなし
      - 新規ユーザー作成
5. OAuth情報保存

セキュリティ考慮:
- メール確認済みのOAuthアカウントのみ自動連携
- メール未確認の場合は追加認証要求
- ユーザーによる連携解除機能
```

#### パターン3: 複数プロバイダ連携

```
実装:
1. 1ユーザーに複数OAuth連携可能
2. 各プロバイダごとにレコード作成
3. ログイン時はいずれかで認証可能

データ構造:
oauth_accounts テーブルに unique constraint:
- (user_id, provider) ユニーク制約
- provider_user_id ユニーク制約

ユーザー設定画面:
- 連携済みアカウント一覧
- 新規連携追加ボタン
- 連携解除ボタン(最後の認証手段は残す)
```

### OAuth実装の詳細

#### State パラメータによるCSRF対策

```
実装:
1. 認可リクエスト前にランダムなstate生成
2. セッション or 一時ストレージに保存
3. 認可URLにstate含める
4. コールバック時にstate検証
5. 一致すれば処理継続、不一致ならエラー
```

#### PKCE(Proof Key for Code Exchange)

```
用途: モバイルアプリ、SPA等のパブリッククライアント

フロー:
1. code_verifierをランダム生成
2. code_challengeを生成(code_verifierのハッシュ)
3. 認可リクエストにcode_challenge含める
4. トークン交換時にcode_verifier送信
5. プロバイダ側で検証
```

#### トークンリフレッシュ

```
実装:
1. OAuthアクセストークンの有効期限管理
2. 期限切れ前/後にリフレッシュトークンで更新
3. 新しいトークンをDBに保存
4. リフレッシュ失敗時の再認証フロー
```

---

## Remember Me実装

### 永続的トークン方式

ユーザーがログイン状態を長期間保持できる機能。

### 実装パターン

#### パターン1: 永続的トークン

```
フロー:
1. ログイン時に「Remember Me」チェック
2. 永続的トークン生成
   - セレクタ(識別子、ランダム32byte)
   - バリデータ(検証用、ランダム32byte)
3. バリデータをハッシュ化してDB保存
4. セレクタ:バリデータをCookieに保存(有効期限30日等)

検証フロー:
1. Cookieからセレクタ:バリデータ取得
2. セレクタでDB検索
3. バリデータをハッシュ化して比較
4. 一致すればユーザーログイン
5. 不一致なら全Remember Meトークン削除(セキュリティ)

データ構造:
remember_tokens テーブル:
- token_id
- user_id
- selector (インデックス)
- validator_hash
- created_at
- expires_at
- last_used_at
- device_info
```

#### パターン2: トークンローテーション

```
強化版フロー:
1. Remember Me検証成功
2. 古いトークン削除
3. 新しいトークン生成
4. 新しいトークンでCookie更新

メリット:
- トークン盗難時の被害を限定
- 使用履歴の追跡が容易
```

### Remember Meのセキュリティ

**セキュリティ考慮事項:**

```
1. トークンの強度
   - セレクタ、バリデータともに32byte以上
   - 暗号学的に安全な乱数生成

2. ハッシュ化
   - バリデータは必ずハッシュ化して保存
   - bcrypt, argon2等の強力なハッシュ関数

3. 有効期限
   - 適切な有効期限設定(30日程度)
   - アイドルタイムアウトとの併用

4. デバイス制限
   - ユーザーごとのトークン数制限
   - デバイス情報の記録

5. セキュリティイベント時の対応
   - パスワード変更時に全トークン削除
   - 不正検知時に全トークン削除

6. Cookie設定
   - HttpOnly: true (XSS対策)
   - Secure: true (HTTPS必須)
   - SameSite: Lax or Strict (CSRF対策)

7. 重要操作時の再認証
   - パスワード変更
   - メール変更
   - 決済処理
   - アカウント削除
```

**実装例:**

```
重要操作の再認証フロー:
1. Remember Meでログイン中の検出
2. 重要操作の前にパスワード再入力要求
3. パスワード検証成功で操作許可
4. 再認証の有効期限(15分等)設定
```

---

## アカウントロックアウト戦略

### 失敗回数ベースのロック

一定回数の認証失敗でアカウントをロックする方式。

**実装:**

```
基本フロー:
1. ログイン失敗時にカウンター増加
2. カウンターが閾値(5回等)に達したらロック
3. ロック時間経過 or 管理者操作で解除
4. ログイン成功時にカウンターリセット

データ構造:
users テーブルに追加:
- failed_login_attempts (失敗回数)
- locked_until (ロック解除時刻)
- last_failed_login_at (最終失敗時刻)

または専用テーブル:
login_attempts テーブル:
- attempt_id
- user_id or ip_address
- attempted_at
- success (成功/失敗)
```

### 時間ベースのロック

時間ウィンドウ内の失敗回数でロックする方式。

**実装:**

```
フロー:
1. 過去N分間の失敗回数をカウント
2. 閾値超過でロック
3. 時間経過で自動解除

例: 10分間に5回失敗したら30分ロック

利点:
- 時間経過で自然に解除
- 永続的なロックを避ける
```

### 段階的な制限

失敗回数に応じて段階的に制限を強化する方式。

**実装:**

```
段階的遅延:
1. 1-2回失敗: 即座に応答
2. 3-4回失敗: 2秒遅延
3. 5-6回失敗: 5秒遅延
4. 7回以上失敗: 10秒遅延 + 一時ロック

または:
1. 3回失敗: CAPTCHA要求
2. 5回失敗: メール確認要求
3. 10回失敗: アカウントロック

利点:
- 正規ユーザーへの影響を最小化
- ブルートフォース攻撃を効果的に防止
```

### ロックアウト実装の詳細

#### IPアドレスベースの制限

```
実装:
1. IPアドレスごとに失敗回数カウント
2. 同一IPからの大量失敗を検出
3. IPレベルでの一時ブロック

データ構造:
ip_login_attempts テーブル:
- ip_address (主キー or インデックス)
- failed_attempts
- last_attempt_at
- blocked_until

考慮事項:
- NAT環境での誤検知
- 共有IPアドレス(会社、公共Wi-Fi等)
- プロキシ経由のアクセス
```

#### 通知とリカバリー

```
ロック時の対応:
1. ユーザーへのメール通知
   - ロックされた旨
   - 解除方法(時間経過 or パスワードリセット)
   - 心当たりがない場合の対処法

2. 管理者への通知
   - 異常なロックアウトパターン検出時
   - 同一IPからの複数アカウント攻撃

3. リカバリーオプション:
   - 時間経過での自動解除
   - パスワードリセット経由の解除
   - 管理者による手動解除
   - セキュリティ質問での解除
```

#### ロックアウト回避攻撃への対策

```
分散攻撃への対策:
1. IPアドレス単位の制限
2. グローバルなレート制限
3. 異常パターンの検出
   - 辞書攻撃パターン
   - 同一パスワードの複数アカウント試行

考慮すべき攻撃:
1. 意図的なロックアウト(DoS)
   - 他人のアカウントを故意にロック
   - 対策: CAPTCHA、メール確認等の追加ステップ

2. スロー攻撃
   - ロック閾値直前で停止を繰り返す
   - 対策: 累積失敗回数の長期監視

3. 分散攻撃
   - 複数IPからの攻撃
   - 対策: アカウント単位 + IP単位の両方で制限
```

---

## 総合的な実装ガイドライン

### セキュリティチェックリスト

```
認証全般:
□ パスワードは適切にハッシュ化(bcrypt, argon2等)
□ ソルトは自動生成・ユーザーごとに異なる
□ HTTPS強制
□ セッション/トークンの安全な保存
□ CSRF対策実装
□ XSS対策実装
□ SQLインジェクション対策

認証フロー:
□ タイミング攻撃対策
□ レート制限実装
□ ロックアウト機能
□ MFAオプション提供
□ パスワード強度チェック
□ セキュアなパスワードリセット

セッション管理:
□ セッションID再生成(ログイン時)
□ 適切な有効期限設定
□ セッション固定攻撃対策
□ セッションハイジャック対策
□ ログアウト時の完全なクリーンアップ

トークン管理:
□ トークンの安全な生成
□ 適切な有効期限
□ トークン無効化機能
□ リフレッシュトークンローテーション
□ トークン盗難時の対応手順

ログとモニタリング:
□ 認証イベントのログ記録
□ 異常なパターンの検出
□ セキュリティアラート
□ 定期的なログレビュー
```

### パフォーマンス最適化

```
1. パスワードハッシュ化
   - 適切なコストパラメータ設定
   - ハッシュ化処理の非同期実行

2. セッション/トークン検証
   - キャッシュの活用
   - DBクエリの最適化
   - インデックスの適切な設定

3. レート制限
   - インメモリカウンター(Redis等)
   - 分散環境での同期

4. MFA
   - TOTP検証の最適化
   - SMS送信の非同期処理
```

### ユーザビリティ考慮

```
1. エラーメッセージ
   - セキュリティとのバランス
   - ユーザーフレンドリーな表現
   - 具体的な解決策の提示

2. パスワード要件
   - 明確な要件表示
   - リアルタイムバリデーション
   - 強度インジケーター

3. MFA
   - オプトイン方式
   - バックアップ方法の提供
   - デバイス信頼機能

4. Remember Me
   - 明確な説明
   - セキュリティリスクの通知
   - デバイス管理機能
```

---

このドキュメントは、認証フローの設計・実装時の包括的なガイドとして活用してください。フレームワークやライブラリに依存しない原則と パターンを示しているため、任意の技術スタックに適用可能です。
