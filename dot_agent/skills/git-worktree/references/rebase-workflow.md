# rebase ワークフロー詳細

## 目次

- [merge vs rebase](#merge-vs-rebase)
  - [比較](#比較)
  - [rebase 推奨理由（並列開発での採用根拠）](#rebase-推奨理由（並列開発での採用根拠）)
- [基本 rebase フロー](#基本-rebase-フロー)
  - [ステップ 1: リモートの最新を取得](#ステップ-1-リモートの最新を取得)
  - [ステップ 2: rebase を実行](#ステップ-2-rebase-を実行)
  - [ステップ 3: コンフリクト解消（発生時）](#ステップ-3-コンフリクト解消（発生時）)
  - [ステップ 4: 安全に push](#ステップ-4-安全に-push)
- [コンフリクト解消の詳細](#コンフリクト解消の詳細)
  - [コンフリクトマーカーの読み方](#コンフリクトマーカーの読み方)
  - [解消パターン](#解消パターン)
  - [複数ファイルのコンフリクト](#複数ファイルのコンフリクト)
  - [rebase の中断](#rebase-の中断)
  - [コンフリクト解消時の注意](#コンフリクト解消時の注意)
- [rebase タイミング戦略](#rebase-タイミング戦略)
  - [マージ前（必須）](#マージ前（必須）)
  - [定期同期（推奨: 半日〜1日ごと）](#定期同期（推奨-半日1日ごと）)
  - [定期同期の頻度調整](#定期同期の頻度調整)
- [インタラクティブ rebase](#インタラクティブ-rebase)
  - [WIP コミットの整理](#wip-コミットの整理)
  - [操作コマンド](#操作コマンド)
  - [整理の指針](#整理の指針)
- [よくある rebase の問題](#よくある-rebase-の問題)
  - [クイックリファレンス](#クイックリファレンス)

## merge vs rebase

### 比較

| 観点 | merge | rebase |
|------|-------|--------|
| 履歴 | マージコミットが増える | 直線的な履歴を維持 |
| コンフリクト解消 | 1回で全解消 | コミットごとに解消 |
| bisect | マージコミットが邪魔になりやすい | 直線的で追跡しやすい |
| force push | 不要 | 必要（`--force-with-lease`） |
| 複雑さ | 低い | やや高い |

### rebase 推奨理由（並列開発での採用根拠）

```
1. クリーンな履歴
   → 複数 worktree が同時に動く並列開発では、merge commit が大量に発生する
   → rebase なら直線的な履歴を維持でき、レビュー・デバッグが容易

2. コンフリクトの早期発見
   → rebase はコミット単位でコンフリクトを解消するため、問題箇所が明確
   → merge は全差分を一括で解消するため、大きなコンフリクトになりやすい

3. git bisect との相性
   → 直線的な履歴は bisect でのバグ特定が効率的

4. PR の差分がクリーン
   → rebase 後の PR は親ブランチからの純粋な差分のみを表示
```

## 基本 rebase フロー

### ステップ 1: リモートの最新を取得

```bash
git fetch origin
```

### ステップ 2: rebase を実行

```bash
# 親ブランチに rebase
git rebase {base-branch}

# 例: feature/auth に rebase
git rebase feature/auth

# リモートの最新に直接 rebase する場合
git rebase origin/feature/auth
```

### ステップ 3: コンフリクト解消（発生時）

```bash
# コンフリクトが発生すると rebase が一時停止する
# メッセージ例:
#   CONFLICT (content): Merge conflict in src/auth/login.ts
#   error: could not apply abc1234... feat: ログイン機能を追加

# 1. コンフリクトファイルを確認
git status
# → "both modified" のファイルがコンフリクト対象

# 2. コンフリクトマーカーを確認して解消
# ファイルを開くと以下のようなマーカーがある:
#   <<<<<<< HEAD
#   （親ブランチ側の変更）
#   =======
#   （自分のコミットの変更）
#   >>>>>>> abc1234 (feat: ログイン機能を追加)

# 3. マーカーを削除し、正しいコードに修正
# 4. 解消したファイルをステージング
git add {解消したファイル}

# 5. rebase を続行
git rebase --continue
# → 次のコンフリクトがあれば再度停止、なければ完了
```

### ステップ 4: 安全に push

```bash
# rebase 後は履歴が書き換わるため force push が必要
# --force-with-lease は他の人が push した変更を上書きしない安全策
git push --force-with-lease origin {branch-name}
```

**`--force-with-lease` vs `--force`:**
```
--force           → リモートの状態を無条件に上書き（危険）
--force-with-lease → リモートが期待通りの状態であれば上書き（安全）
  → 他の人が同じブランチに push していた場合は失敗する
  → 失敗時は git fetch → 確認 → 再 push
```

## コンフリクト解消の詳細

### コンフリクトマーカーの読み方

```
<<<<<<< HEAD
// 親ブランチ（rebase 先）のコード
// rebase の場合、HEAD は「親ブランチの最新」を指す
const token = getToken();
=======
// 自分のコミットのコード
const token = await getToken();
>>>>>>> abc1234 (feat: 非同期トークン取得に変更)
```

### 解消パターン

```
パターン 1: 自分の変更を採用
  → HEAD 側を削除し、自分の変更を残す

パターン 2: 親ブランチの変更を採用
  → 自分の変更を削除し、HEAD 側を残す

パターン 3: 両方を統合
  → マーカーを削除し、両方の意図を反映したコードに書き換える
```

### 複数ファイルのコンフリクト

```bash
# すべてのコンフリクトファイルを確認
git status

# ファイルごとに解消
# → エディタで開いて修正
# → git add で解消済みをマーク

# すべて解消したら
git rebase --continue
```

### rebase の中断

```bash
# rebase を中断して元の状態に戻す
git rebase --abort
# → rebase 開始前の状態に完全に戻る
# → コンフリクト解消が複雑すぎる場合に使用
```

### コンフリクト解消時の注意

```
1. テストを実行してから continue
   → 解消後のコードが正しく動作するか確認

2. 1コミットずつ丁寧に解消
   → rebase はコミット単位で適用されるため、各ステップで整合性を確認

3. 同じコンフリクトが繰り返される場合
   → rerere を有効化: git config rerere.enabled true
   → 一度解消したコンフリクトパターンを記憶してくれる
```

## rebase タイミング戦略

### マージ前（必須）

```bash
# PR 作成前に必ず実行
git fetch origin
git rebase {base-branch}
git push --force-with-lease origin {branch-name}

# テストが通ることを確認してから PR を作成
```

### 定期同期（推奨: 半日〜1日ごと）

```
タイミング:
  - 作業開始時（朝一番）
  - 他のタスクブランチが親ブランチにマージされた直後
  - 長時間作業の区切り

判断基準:
  親ブランチに新しいコミットがある？
  ├→ Yes → rebase して同期
  └→ No  → 不要
```

### 定期同期の頻度調整

```
コンフリクトリスクが高い場合（同じ領域を複数人が変更）:
  → 半日ごと、または親ブランチ更新のたびに同期

コンフリクトリスクが低い場合（完全に独立した領域）:
  → 1日ごと、またはマージ前のみでも可
```

## インタラクティブ rebase

### WIP コミットの整理

PR 作成前に、WIP コミットを整理して意味のある単位にまとめる:

```bash
# 親ブランチからのコミットを対象にインタラクティブ rebase
git rebase -i {base-branch}

# エディタが開き、コミット一覧が表示される:
#   pick abc1234 feat: ログインフォームの雛形を作成
#   pick def5678 wip: バリデーション実装中
#   pick ghi9012 wip: バリデーション完了
#   pick jkl3456 test: ログインバリデーションのテスト追加

# 以下のように編集:
#   pick abc1234 feat: ログインフォームの雛形を作成
#   squash def5678 wip: バリデーション実装中
#   squash ghi9012 wip: バリデーション完了
#   pick jkl3456 test: ログインバリデーションのテスト追加
```

### 操作コマンド

| コマンド | 短縮 | 動作 |
|---------|------|------|
| `pick` | `p` | コミットをそのまま使用 |
| `squash` | `s` | 前のコミットに統合（メッセージ編集あり） |
| `fixup` | `f` | 前のコミットに統合（メッセージ破棄） |
| `reword` | `r` | コミットメッセージを変更 |
| `drop` | `d` | コミットを削除 |

### 整理の指針

```
推奨される最終的なコミット構成:
  1コミット = 1つの論理的な変更
  例:
    feat: ログインフォームコンポーネントを追加
    feat: ログインAPIエンドポイントを実装
    test: ログイン機能のテストを追加
    docs: ログイン機能のAPI仕様を追加

避けるべきコミット構成:
    wip: 作業中
    fix: typo修正
    wip: もう少し
    fix: テスト修正
```

## よくある rebase の問題

問題と解決策の詳細は [troubleshooting.md](troubleshooting.md) を参照。

### クイックリファレンス

| 状況 | 対処 |
|------|------|
| コンフリクトが複雑すぎる | `git rebase --abort` で中断 |
| force-with-lease が失敗 | `git fetch origin` → 差分確認 → 再 push |
| detached HEAD になった | `git checkout {branch-name}` |
| rebase 後にテストが通らない | コンフリクト解消を見直し、必要なら `--abort` |
