# 正規化詳細と判断フロー

## 目次

1. [正規化レベルの詳細](#正規化レベルの詳細)
2. [正規化判断フロー](#正規化判断フロー)
3. [非正規化パターン](#非正規化パターン)
4. [アンチパターン](#アンチパターン)

---

## 正規化レベルの詳細

### 第1正規形 (1NF)

**条件**: すべてのカラムが原子値（スカラー値）を持つ

```
❌ 違反例:
users テーブル
| id | name | phones              |
|----|------|---------------------|
| 1  | 田中 | 090-xxxx, 080-xxxx  |

✅ 修正:
users テーブル          user_phones テーブル
| id | name |          | user_id | phone    |
|----|------|          |---------|----------|
| 1  | 田中 |          | 1       | 090-xxxx |
                       | 1       | 080-xxxx |
```

**チェック項目**:
- カンマ区切りの値がないか
- JSON 配列で代替しているものがないか（検索対象なら別テーブル化）
- 繰り返しカラム（phone1, phone2, phone3）がないか

### 第2正規形 (2NF)

**条件**: 1NF + すべての非キー属性が主キー全体に完全関数従属

```
❌ 違反例（複合主キー: order_id + product_id）:
| order_id | product_id | product_name | quantity |
|----------|------------|--------------|----------|
→ product_name は product_id だけで決まる（部分関数従属）

✅ 修正:
order_items テーブル        products テーブル
| order_id | product_id |  | product_id | product_name |
|          | quantity    |  |            |              |
```

**チェック項目**:
- 複合主キーの一部だけで決まる属性がないか
- 単一主キー（auto increment / UUID）なら 2NF は自動的に満たされる

### 第3正規形 (3NF)

**条件**: 2NF + 非キー属性間の推移的関数従属がない

```
❌ 違反例:
| employee_id | department_id | department_name |
→ department_name は department_id に依存（推移的従属）

✅ 修正:
employees テーブル          departments テーブル
| employee_id |             | department_id | department_name |
| department_id |           |               |                 |
```

**チェック項目**:
- 非キーカラムが別の非キーカラムに依存していないか
- 「A → B → C」の依存チェーンがないか

### ボイス・コッド正規形 (BCNF)

**条件**: すべての関数従属の決定項が候補キー

- 3NF との違いは実務上稀
- 複合候補キーが複数存在する場合に問題になる
- 通常は 3NF で十分

## 正規化判断フロー

```
テーブル設計が完了
  │
  ├→ カンマ区切り・繰り返しカラムがある？
  │   Yes → 別テーブルに分離 (1NF)
  │
  ├→ 複合主キーを使っている？
  │   Yes → 部分関数従属がある？
  │          Yes → テーブル分割 (2NF)
  │
  ├→ 非キー属性間の依存がある？
  │   Yes → 依存先を別テーブルに (3NF)
  │
  └→ 3NF 完了
      │
      └→ パフォーマンス要件で非正規化が必要？
          Yes → 非正規化パターンを適用
          No  → 3NF のまま運用
```

## 非正規化パターン

### 1. 事前計算カラム

```
用途: 集計値の高速取得
例:   orders.total_amount（order_items の合計）

更新タイミング:
  - order_items の追加/更新/削除時にトリガーで更新
  - または定期バッチで再計算

注意:
  - 更新頻度 vs 参照頻度のバランス
  - 整合性確保の仕組みが必須
```

### 2. 冗長カラム

```
用途: JOIN 回避
例:   orders.customer_name（customers.name のコピー）

適用条件:
  - 元データの更新頻度が低い
  - 参照時に常に JOIN が必要
  - 履歴的な意味がある（注文時の名前を保持）

注意:
  - 元データ変更時の同期が必要（履歴保持が目的なら不要）
```

### 3. スナップショット

```
用途: ある時点の状態を保持
例:   order_snapshots（注文確定時の商品情報・価格）

適用条件:
  - 法的・ビジネス要件で履歴保持が必要
  - 元データが頻繁に変更される

設計:
  - JSON カラムで柔軟に保持
  - または専用の履歴テーブル
```

## アンチパターン

### Entity-Attribute-Value (EAV)

```
❌ 避けるべき:
| entity_id | attribute  | value   |
|-----------|-----------|---------|
| 1         | name      | 田中    |
| 1         | email     | t@e.com |

問題:
  - 型安全性がない
  - 制約が効かない
  - クエリが複雑になる
  - パフォーマンスが悪い

代替案:
  - jsonb カラム（動的属性が本当に必要な場合）
  - テーブル継承パターン
```

### 多目的テーブル

```
❌ 避けるべき:
| id | type    | ref_id | data  |
|----|---------|--------|-------|
| 1  | comment | 42     | ...   |
| 2  | tag     | 42     | ...   |

問題:
  - 外部キー制約が効かない
  - 型ごとに異なるカラムが必要
  - クエリが複雑

代替案:
  - 用途ごとに専用テーブルを作成
  - ポリモーフィックアソシエーションが必要なら
    中間テーブルで対応
```

### 過剰な正規化

```
❌ やりすぎ:
  - 都道府県を別テーブルにする（マスタ管理が不要なら）
  - 単一の enum 値を別テーブルにする
  - すべてのフィールドを別テーブルに分離

判断基準:
  - マスタデータとして独立管理が必要か？
  - 他のテーブルからも参照されるか？
  - No なら正規化しない（カラムのまま保持）
```
