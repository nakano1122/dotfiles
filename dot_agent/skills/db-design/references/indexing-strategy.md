# インデックス戦略詳細

## 目次

1. [インデックスの基本原理](#インデックスの基本原理)
2. [インデックスの種類と選択](#インデックスの種類と選択)
3. [複合インデックス設計](#複合インデックス設計)
4. [パフォーマンス分析](#パフォーマンス分析)
5. [アンチパターン](#アンチパターン)

---

## インデックスの基本原理

### インデックスが効く場面

| 操作 | インデックス効果 |
|------|-----------------|
| 等値検索 (=) | 高 |
| 範囲検索 (<, >, BETWEEN) | 高 |
| ORDER BY | 高（ソート回避） |
| JOIN (外部キー) | 高 |
| LIKE 'prefix%' | 高（前方一致のみ） |
| LIKE '%suffix' | 低（後方一致は効かない） |
| 関数適用 (LOWER(col)) | 低（式インデックスが必要） |

### インデックスのコスト

```
メリット:
  - SELECT のパフォーマンス向上
  - ソート操作の回避
  - 一意性制約の高速化

コスト:
  - INSERT/UPDATE/DELETE が遅くなる（インデックス更新）
  - ストレージ使用量の増加
  - 多すぎるとオプティマイザの判断が遅くなる
```

## インデックスの種類と選択

### B-Tree インデックス（デフォルト）

```
用途: 等値検索、範囲検索、ソート
適用: ほとんどの場面で使用

特徴:
  - 最も汎用的
  - 等値・範囲・ソートすべてに対応
  - NULL 値も含められる
```

### ハッシュインデックス

```
用途: 等値検索のみ（範囲検索には使えない）
適用: 完全一致検索が多い場面

特徴:
  - 等値検索は B-Tree より高速
  - 範囲検索・ソートには使えない
  - 一部の DB でのみサポート
```

### 部分インデックス（Partial Index）

```
用途: 特定条件に合致する行のみインデックス化
適用: 特定のステータスのみ頻繁に検索する場合

例:
  CREATE INDEX idx_active_users ON users (email)
  WHERE is_active = true;

メリット:
  - インデックスサイズが小さい
  - 更新コストが低い
  - 特定クエリの性能が高い
```

### 全文検索インデックス

```
用途: テキスト検索
適用: 記事本文、商品説明などの自然言語検索

注意:
  - DB によって実装が異なる
  - 専用の検索エンジンの方が適切な場合もある
```

### 式インデックス（Expression Index）

```
用途: 関数・式の結果にインデックス
適用: LOWER(email) での検索など

例:
  CREATE INDEX idx_lower_email ON users (LOWER(email));

注意:
  - クエリの式とインデックスの式が一致する必要がある
```

## 複合インデックス設計

### 左端一致原則（Leftmost Prefix Rule）

```
CREATE INDEX idx_abc ON table (a, b, c);

✅ このインデックスが使える:
  WHERE a = 1
  WHERE a = 1 AND b = 2
  WHERE a = 1 AND b = 2 AND c = 3
  WHERE a = 1 ORDER BY b

❌ このインデックスが使えない:
  WHERE b = 2                    ← a が含まれていない
  WHERE b = 2 AND c = 3          ← a が含まれていない
  WHERE a = 1 AND c = 3          ← b が飛ばされている（a は使える）
```

### カラム順序の決定基準

```
1. 等値条件のカラムを先に
2. 範囲条件のカラムを後に
3. カーディナリティが高いカラムを先に（一般的に）

例: status = 'active' AND created_at > '2024-01-01'
  → CREATE INDEX idx ON table (status, created_at);
```

### カバリングインデックス

```
SELECT name, email FROM users WHERE status = 'active';

CREATE INDEX idx_covering ON users (status, name, email);
→ インデックスだけで結果を返せる（テーブルアクセス不要）

メリット:
  - テーブルへのアクセスを回避（Index Only Scan）
  - 大幅なパフォーマンス向上

注意:
  - カラム数が多すぎるとインデックスが肥大化
  - 更新コストが増加
```

## パフォーマンス分析

### 実行計画の確認

```
EXPLAIN ANALYZE で確認すべき項目:

1. Seq Scan vs Index Scan
   → Seq Scan が多い場合はインデックス不足の可能性

2. コスト（cost）と実行時間（actual time）
   → 期待より遅い場合はインデックス戦略を見直し

3. Rows（推定行数 vs 実行行数）
   → 大きな乖離は統計情報の更新が必要
```

### インデックス効果の判断

```
インデックスが効果的:
  - テーブルの行数が多い（数千行以上）
  - 選択性が高い（対象行が全体の10-15%以下）
  - 検索頻度が高い

インデックスが不要/逆効果:
  - テーブルの行数が少ない（数百行以下）
  - 選択性が低い（boolean カラムへの単独インデックス等）
  - 書き込みが非常に多い
```

## アンチパターン

### 1. すべてのカラムにインデックス

```
❌ 問題:
  - 書き込み性能が大幅に低下
  - ストレージの浪費
  - オプティマイザが最適なインデックスを選びにくくなる

✅ 方針:
  - 実際のクエリパターンに基づいてインデックスを設計
  - スロークエリログから必要なインデックスを特定
```

### 2. 使われないインデックスの放置

```
❌ 問題:
  - 書き込みコストだけ発生
  - ストレージの浪費

✅ 方針:
  - 定期的にインデックス使用状況を確認
  - 未使用インデックスは削除を検討
```

### 3. 重複インデックス

```
❌ 重複:
  INDEX idx_a ON table (a);
  INDEX idx_ab ON table (a, b);
  → idx_a は idx_ab で代替可能

✅ 方針:
  - 複合インデックスの左端一致を活用
  - 単独インデックスが複合の先頭と一致する場合は削除
```

### 4. ソートと検索の不一致

```
❌ インデックスが活かせない:
  CREATE INDEX idx ON table (a ASC, b ASC);
  SELECT * FROM table ORDER BY a ASC, b DESC;
  → ソート方向が一致しない

✅ 方針:
  - クエリの ORDER BY と同じ方向でインデックスを作成
```
