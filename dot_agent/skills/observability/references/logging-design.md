# ログ設計パターン詳細

## 目次

1. [概要](#概要)
2. [構造化ログフォーマット](#構造化ログフォーマット)
   - [基本構造](#基本構造)
   - [JSON形式の例](#json形式の例)
   - [必須フィールド](#必須フィールド)
   - [推奨フィールド](#推奨フィールド)
3. [ログコンテキストエンリッチメント](#ログコンテキストエンリッチメント)
   - [リクエストスコープのコンテキスト](#リクエストスコープのコンテキスト)
   - [アプリケーションスコープのコンテキスト](#アプリケーションスコープのコンテキスト)
   - [コンテキスト伝播パターン](#コンテキスト伝播パターン)
4. [リクエストログミドルウェア設計](#リクエストログミドルウェア設計)
   - [基本的なリクエストログ](#基本的なリクエストログ)
   - [詳細なリクエストログ](#詳細なリクエストログ)
   - [ミドルウェア実装パターン](#ミドルウェア実装パターン)
5. [エラーログのベストプラクティス](#エラーログのベストプラクティス)
   - [エラーログの必須情報](#エラーログの必須情報)
   - [スタックトレースの扱い](#スタックトレースの扱い)
   - [エラー分類とログレベル](#エラー分類とログレベル)
   - [ユーザーエラー vs システムエラー](#ユーザーエラー-vs-システムエラー)
6. [ログローテーション・保持ポリシー](#ログローテーション保持ポリシー)
   - [ローテーション戦略](#ローテーション戦略)
   - [保持期間の設計](#保持期間の設計)
   - [ストレージ考慮事項](#ストレージ考慮事項)
7. [機密データマスキングパターン](#機密データマスキングパターン)
   - [マスキング対象](#マスキング対象)
   - [マスキング手法](#マスキング手法)
   - [実装パターン](#実装パターン)
8. [パフォーマンスログパターン](#パフォーマンスログパターン)
   - [レスポンスタイム計測](#レスポンスタイム計測)
   - [データベースクエリログ](#データベースクエリログ)
   - [外部API呼び出しログ](#外部api呼び出しログ)
   - [パフォーマンス閾値アラート](#パフォーマンス閾値アラート)
9. [監査ログ設計](#監査ログ設計)
   - [監査ログの目的](#監査ログの目的)
   - [記録すべき操作](#記録すべき操作)
   - [監査ログの必須フィールド](#監査ログの必須フィールド)
   - [改ざん防止と長期保存](#改ざん防止と長期保存)

---

## 概要

このドキュメントでは、フレームワークに依存しないログ設計のパターンとベストプラクティスを詳述します。構造化ログ、コンテキスト管理、セキュリティ、パフォーマンス、監査の観点からログ設計を支援します。

---

## 構造化ログフォーマット

### 基本構造

構造化ログは機械可読な形式（主にJSON）でログを出力し、検索・集計・分析を容易にします。

**設計原則:**
- 一貫したフィールド名を使用
- データ型を明確にする（文字列、数値、真偽値）
- ネストは適度に（2〜3階層まで）
- タイムスタンプはISO 8601形式

### JSON形式の例

```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "level": "info",
  "message": "User login successful",
  "service": "auth-service",
  "version": "1.2.3",
  "environment": "production",
  "request_id": "req-abc123",
  "trace_id": "trace-xyz789",
  "user_id": "user-456",
  "ip_address": "203.0.113.42",
  "user_agent": "Mozilla/5.0...",
  "context": {
    "action": "login",
    "method": "POST",
    "path": "/api/auth/login",
    "status_code": 200,
    "duration_ms": 45
  }
}
```

### 必須フィールド

すべてのログエントリに含めるべきフィールド:

| フィールド | 説明 | 例 |
|----------|------|-----|
| `timestamp` | ログ出力時刻（UTC） | `2026-02-12T10:30:45.123Z` |
| `level` | ログレベル | `debug`, `info`, `warn`, `error`, `fatal` |
| `message` | 人間が読めるメッセージ | `"User login successful"` |
| `service` | サービス名 | `"auth-service"` |

### 推奨フィールド

可能な限り含めるべきフィールド:

| フィールド | 説明 | 例 |
|----------|------|-----|
| `version` | アプリケーションバージョン | `"1.2.3"` |
| `environment` | 実行環境 | `"production"`, `"staging"` |
| `request_id` | リクエストID（トレーシング用） | `"req-abc123"` |
| `trace_id` | 分散トレーシングID | `"trace-xyz789"` |
| `hostname` | ホスト名/コンテナID | `"app-01"` |

---

## ログコンテキストエンリッチメント

### リクエストスコープのコンテキスト

各HTTPリクエストに紐づくコンテキスト情報:

```json
{
  "request": {
    "id": "req-abc123",
    "method": "POST",
    "path": "/api/users",
    "query": "?page=1&limit=10",
    "ip": "203.0.113.42",
    "user_agent": "Mozilla/5.0..."
  },
  "user": {
    "id": "user-456",
    "email": "user@example.com",
    "role": "admin"
  },
  "session": {
    "id": "sess-xyz789",
    "created_at": "2026-02-12T10:00:00Z"
  }
}
```

### アプリケーションスコープのコンテキスト

アプリケーション全体で共通のコンテキスト:

```json
{
  "service": "user-service",
  "version": "1.2.3",
  "environment": "production",
  "region": "ap-northeast-1",
  "deployment_id": "deploy-20260212-001",
  "hostname": "app-server-01",
  "process_id": 12345
}
```

### コンテキスト伝播パターン

**パターン1: スレッドローカルストレージ**
- スレッド/コルーチン単位でコンテキストを管理
- リクエスト開始時にコンテキストを設定
- リクエスト終了時にクリア

**パターン2: コンテキストオブジェクト引数**
- 関数/メソッドの引数としてコンテキストを渡す
- 明示的で追跡しやすい
- 関数シグネチャが増える

**パターン3: ロガーインスタンスのバインド**
- リクエスト開始時にコンテキスト付きロガーを生成
- そのロガーを各層で使用
- 推奨パターン（明示的かつ柔軟）

```
// 疑似コード
logger = baseLogger.with({
  request_id: "req-abc123",
  user_id: "user-456"
})

// 以降このloggerを使えば自動的にコンテキストが付与される
logger.info("Processing request")
```

---

## リクエストログミドルウェア設計

### 基本的なリクエストログ

**リクエスト開始時:**
```json
{
  "timestamp": "2026-02-12T10:30:45.000Z",
  "level": "info",
  "message": "Request started",
  "request_id": "req-abc123",
  "method": "POST",
  "path": "/api/users",
  "ip": "203.0.113.42"
}
```

**リクエスト完了時:**
```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "level": "info",
  "message": "Request completed",
  "request_id": "req-abc123",
  "method": "POST",
  "path": "/api/users",
  "status_code": 201,
  "duration_ms": 123,
  "ip": "203.0.113.42"
}
```

### 詳細なリクエストログ

本番環境では以下を追加検討:

```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "level": "info",
  "message": "Request completed",
  "request_id": "req-abc123",
  "trace_id": "trace-xyz789",
  "method": "POST",
  "path": "/api/users",
  "status_code": 201,
  "duration_ms": 123,
  "ip": "203.0.113.42",
  "user_agent": "Mozilla/5.0...",
  "user_id": "user-456",
  "request_size_bytes": 1024,
  "response_size_bytes": 512,
  "db_query_count": 3,
  "db_duration_ms": 45,
  "cache_hit": true
}
```

### ミドルウェア実装パターン

**実装の流れ:**
1. リクエスト受信時にrequest_idを生成
2. リクエスト開始ログを出力（オプション）
3. 処理を実行
4. レスポンス時にメトリクスを計測
5. リクエスト完了ログを出力
6. コンテキストをクリア

**ログ出力のタイミング判断:**
- **開始ログ**: 長時間実行されるリクエストの追跡に有用。高トラフィックならスキップも検討
- **完了ログ**: 必須。メトリクスと紐づける

**フィルタリング:**
- ヘルスチェックエンドポイントはログを抑制
- 静的アセットはログレベルを下げる

---

## エラーログのベストプラクティス

### エラーログの必須情報

```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "level": "error",
  "message": "Database connection failed",
  "error": {
    "type": "DatabaseConnectionError",
    "message": "Connection timeout after 5s",
    "code": "DB_CONN_TIMEOUT",
    "stack_trace": "Error: Connection timeout...\n  at connect...",
    "cause": "Network unreachable"
  },
  "request_id": "req-abc123",
  "user_id": "user-456",
  "context": {
    "database": "users_db",
    "host": "db.example.com",
    "port": 5432,
    "retry_count": 3
  }
}
```

### スタックトレースの扱い

**開発環境:**
- フルスタックトレースを出力
- ソースコードの行番号を含める

**本番環境:**
- スタックトレースをフィールドとして構造化
- 機密情報を含まないよう注意
- エラートラッキングサービス（Sentry等）に送信も検討

### エラー分類とログレベル

| レベル | 用途 | 例 |
|--------|------|-----|
| `error` | 処理失敗だが復旧可能 | DB接続失敗（リトライで復旧）、外部API呼び出し失敗 |
| `fatal` | システム停止を伴う致命的エラー | 起動時設定エラー、メモリ不足 |
| `warn` | 潜在的な問題 | 非推奨API使用、リソース使用率高 |

### ユーザーエラー vs システムエラー

**ユーザーエラー（400系）:**
- ログレベル: `info` または `warn`
- バリデーションエラー、認証失敗など
- スタックトレース不要

```json
{
  "level": "info",
  "message": "Validation error",
  "error": {
    "type": "ValidationError",
    "code": "INVALID_INPUT",
    "fields": {
      "email": "Invalid email format"
    }
  }
}
```

**システムエラー（500系）:**
- ログレベル: `error`
- スタックトレース必須
- アラート対象

---

## ログローテーション・保持ポリシー

### ローテーション戦略

**ファイルベース:**
- 時間ベース: 日次、時間毎
- サイズベース: 100MB, 1GB毎
- 併用: 日次または1GB

**クラウドベース:**
- ログ集約サービスに直接送信（推奨）
- ローカルログは最小限（障害時のバックアップのみ）

### 保持期間の設計

| ログ種類 | ホットストレージ | コールドストレージ | 削除 |
|---------|----------------|-------------------|------|
| アクセスログ | 7日 | 30日 | 90日後 |
| エラーログ | 30日 | 180日 | 1年後 |
| 監査ログ | 90日 | 7年 | 法令に従う |
| デバッグログ | 1日 | なし | 7日後 |

### ストレージ考慮事項

**容量見積もり:**
- 1リクエスト = 約1KB（構造化ログ）
- 1000 req/s = 86GB/日
- 圧縮で60-70%削減可能

**コスト最適化:**
- ログレベルで保持期間を分ける
- サンプリング（高トラフィック時）
- 不要なフィールドを削除

---

## 機密データマスキングパターン

### マスキング対象

**必ずマスキング:**
- パスワード、APIキー、トークン
- クレジットカード番号
- 個人識別情報（PII）: メール、電話番号、住所

**条件付きマスキング:**
- IPアドレス（GDPR地域）
- ユーザーID（サービスによる）

### マスキング手法

**完全マスキング:**
```json
{
  "password": "********",
  "api_key": "********"
}
```

**部分マスキング:**
```json
{
  "email": "u***@example.com",
  "credit_card": "****-****-****-1234",
  "phone": "***-****-5678"
}
```

**ハッシュ化:**
```json
{
  "user_id_hash": "a3f5b8c9d2e1f4a6b7c8d9e0f1a2b3c4"
}
```

### 実装パターン

**パターン1: ロガー出力時にマスキング**
- ロガーにマスキングルールを設定
- フィールド名ベース（例: `password`, `token`を含むフィールド）
- 正規表現ベース（例: クレジットカード番号パターン）

**パターン2: ログ構造体作成時にマスキング**
- データ構造をログ用に変換する際にマスキング
- 明示的で制御しやすい

**パターン3: ログ収集パイプラインでマスキング**
- ログ集約サービス側でマスキング
- アプリケーションコードに影響しない
- バックアップとして有用

---

## パフォーマンスログパターン

### レスポンスタイム計測

```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "level": "info",
  "message": "Request completed",
  "request_id": "req-abc123",
  "method": "GET",
  "path": "/api/users/123",
  "status_code": 200,
  "duration_ms": 145,
  "timing": {
    "auth_ms": 12,
    "db_query_ms": 89,
    "business_logic_ms": 23,
    "serialization_ms": 21
  }
}
```

### データベースクエリログ

```json
{
  "timestamp": "2026-02-12T10:30:45.050Z",
  "level": "debug",
  "message": "Database query executed",
  "request_id": "req-abc123",
  "query": {
    "type": "SELECT",
    "table": "users",
    "duration_ms": 45,
    "rows_returned": 1,
    "query_hash": "a3f5b8c9",
    "slow_query": false
  }
}
```

**スロークエリ検出:**
- 閾値を設定（例: 100ms）
- 閾値超過時にログレベルを `warn` に
- クエリプランを追加でログ

### 外部API呼び出しログ

```json
{
  "timestamp": "2026-02-12T10:30:45.080Z",
  "level": "info",
  "message": "External API call completed",
  "request_id": "req-abc123",
  "external_api": {
    "service": "payment-gateway",
    "method": "POST",
    "endpoint": "/v1/charges",
    "status_code": 200,
    "duration_ms": 234,
    "retry_count": 0,
    "timeout": false
  }
}
```

### パフォーマンス閾値アラート

**閾値設定例:**
- P50 < 100ms: 正常
- P95 < 300ms: 正常
- P99 < 1000ms: 正常
- P99 > 1000ms: アラート

**実装:**
```json
{
  "level": "warn",
  "message": "Slow request detected",
  "request_id": "req-abc123",
  "duration_ms": 2345,
  "threshold_ms": 1000,
  "alert": true
}
```

---

## 監査ログ設計

### 監査ログの目的

- コンプライアンス要件の充足
- セキュリティインシデント調査
- ユーザー行動の追跡
- 改ざんの検出と防止

### 記録すべき操作

**必須:**
- ユーザー認証（ログイン、ログアウト、失敗）
- 認可変更（ロール変更、権限付与）
- データの作成・更新・削除（CRUD）
- 管理者操作
- セキュリティ設定変更

**推奨:**
- データアクセス（閲覧）
- エクスポート操作
- API キー生成・取り消し

### 監査ログの必須フィールド

```json
{
  "timestamp": "2026-02-12T10:30:45.123Z",
  "audit_id": "audit-abc123",
  "event_type": "user.role.updated",
  "severity": "high",
  "actor": {
    "user_id": "admin-789",
    "email": "admin@example.com",
    "role": "admin",
    "ip": "203.0.113.42",
    "user_agent": "Mozilla/5.0..."
  },
  "target": {
    "user_id": "user-456",
    "email": "user@example.com"
  },
  "action": {
    "operation": "update",
    "resource": "user",
    "resource_id": "user-456",
    "details": {
      "field": "role",
      "old_value": "user",
      "new_value": "moderator"
    }
  },
  "result": "success",
  "request_id": "req-abc123"
}
```

### 改ざん防止と長期保存

**改ざん防止:**
- 追記のみのストレージ（append-only）
- 署名・ハッシュ化（チェーン）
- 外部監査ログサービスへの送信

**長期保存:**
- 法令で定められた期間（一般的に5〜7年）
- 暗号化保存
- バックアップとリストア手順の確立

**アクセス制御:**
- 監査ログへのアクセスを制限
- 監査ログのアクセスも監査

---

## まとめ

効果的なログ設計は、可観測性の基盤です。このリファレンスで示したパターンを参考に、プロジェクトのニーズに合わせてカスタマイズしてください。

**重要ポイント:**
- 構造化ログで検索性を確保
- コンテキストを適切に付与
- 機密データを保護
- パフォーマンスと監査の両面に配慮
- ログの量とコストのバランスを取る
